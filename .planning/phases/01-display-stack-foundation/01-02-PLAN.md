---
phase: 01-display-stack-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - cobrowse/runtime/cobrowse-start.sh
  - cobrowse/runtime/cobrowse-stop.sh
  - cobrowse/runtime/cobrowse-status.sh
autonomous: false

must_haves:
  truths:
    - "cobrowse-start.sh starts Xvfb, VNC, noVNC, and Chromium in correct dependency order"
    - "cobrowse-stop.sh cleanly stops all services in reverse order"
    - "cobrowse-status.sh reports health of all 4 components with pass/fail"
    - "User opens http://container-ip:6080/vnc.html in laptop browser and sees Chromium"
    - "User can click and type in Chromium via noVNC interface"
    - "CDP endpoint responds at localhost:9222"
    - "Browser session survives stop/start cycle (cookies persist via --user-data-dir)"
  artifacts:
    - path: "cobrowse/runtime/cobrowse-start.sh"
      provides: "One-command start of entire display stack"
      contains: "systemctl --user start"
    - path: "cobrowse/runtime/cobrowse-stop.sh"
      provides: "One-command stop of entire display stack"
      contains: "systemctl --user stop"
    - path: "cobrowse/runtime/cobrowse-status.sh"
      provides: "Health check reporting for all services"
      contains: "xdpyinfo"
  key_links:
    - from: "cobrowse/runtime/cobrowse-start.sh"
      to: "cobrowse/systemd/*.service"
      via: "systemctl --user start service@instance"
      pattern: "systemctl.*start"
    - from: "cobrowse/runtime/cobrowse-status.sh"
      to: "localhost:9222"
      via: "curl health check"
      pattern: "curl.*9222"
    - from: "cobrowse/runtime/cobrowse-start.sh"
      to: "/home/dev/.cobrowse/display.env"
      via: "sources env file for display number and ports"
      pattern: "source.*display.env"
---

<objective>
Create runtime management scripts (start, stop, status) and verify the complete display stack works end-to-end.

Purpose: The setup script (Plan 01) installs everything; these scripts operate the stack day-to-day. The human verification checkpoint confirms the entire Phase 1 goal: browser visible via noVNC with persistent sessions.

Output: Three runtime scripts and human-verified working noVNC + Chromium display stack.
</objective>

<execution_context>
@/home/dev/.claude/get-shit-done/workflows/execute-plan.md
@/home/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-display-stack-foundation/01-RESEARCH.md
@.planning/phases/01-display-stack-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create start, stop, and status runtime scripts</name>
  <files>
    cobrowse/runtime/cobrowse-start.sh
    cobrowse/runtime/cobrowse-stop.sh
    cobrowse/runtime/cobrowse-status.sh
  </files>
  <action>
Create three runtime scripts in cobrowse/runtime/. All scripts source /home/dev/.cobrowse/display.env for configuration (DISPLAY, VNC_PORT, NOVNC_PORT, CDP_PORT).

**cobrowse-start.sh** — Start all display stack services:

1. Shebang + set -euo pipefail
2. Source /home/dev/.cobrowse/display.env (fail with helpful error if missing — tell user to run cobrowse-setup.sh first)
3. Extract display number from DISPLAY var (e.g., ":99" -> "99")
4. Start services in dependency order with wait-for-ready between each:
   a. `systemctl --user start xvfb@${DISPLAY_NUM}` then wait for `xdpyinfo -display :${DISPLAY_NUM}` (up to 10s)
   b. `systemctl --user start tigervnc@${DISPLAY_NUM}` then wait for VNC port listening (up to 10s)
   c. `systemctl --user start novnc@${DISPLAY_NUM}` then wait for noVNC port listening (up to 10s)
   d. `systemctl --user start chromium-cdp@${DISPLAY_NUM}` then wait for CDP responding (up to 30s, Chromium is slow to start)
5. Run the status check at the end
6. Print access URLs:
   - noVNC: http://$(hostname -I | awk '{print $1}'):6080/vnc.html?autoconnect=true
   - CDP: http://localhost:9222/json/version
7. If any service fails to start, print the journalctl output for that service and exit 1

Wait-for-ready pattern:
```bash
wait_for() {
  local desc="$1" cmd="$2" timeout="$3"
  for i in $(seq 1 "$timeout"); do
    if eval "$cmd" >/dev/null 2>&1; then
      echo "  OK: $desc"
      return 0
    fi
    sleep 1
  done
  echo "  FAIL: $desc (timeout after ${timeout}s)"
  return 1
}
```

**cobrowse-stop.sh** — Stop all services in reverse order:

1. Source display.env
2. Stop in reverse dependency order:
   a. `systemctl --user stop chromium-cdp@${DISPLAY_NUM}` (ignore errors — may not be running)
   b. `systemctl --user stop novnc@${DISPLAY_NUM}`
   c. `systemctl --user stop tigervnc@${DISPLAY_NUM}`
   d. `systemctl --user stop xvfb@${DISPLAY_NUM}`
3. Print confirmation

Use `|| true` after each stop command so the script doesn't fail if a service isn't running.

**cobrowse-status.sh** — Health check all components:

1. Source display.env
2. Check each component with clear pass/fail output:
   - Xvfb: `xdpyinfo -display :${DISPLAY_NUM}` → OK/FAIL
   - VNC: `lsof -i :${VNC_PORT}` → OK/FAIL (or use `ss -tlnp | grep ${VNC_PORT}`)
   - noVNC: `curl -s -o /dev/null -w "%{http_code}" http://localhost:${NOVNC_PORT}` → OK if 200/FAIL
   - Chromium CDP: `curl -s http://localhost:${CDP_PORT}/json/version` → OK with version info/FAIL
3. Check systemd service states: `systemctl --user is-active xvfb@${DISPLAY_NUM}` etc.
4. Print summary: X of 4 services healthy
5. Exit 0 if all pass, exit 1 if any fail

All scripts should be chmod +x (the executor should run chmod +x on them after creation).
  </action>
  <verify>
```bash
# Check scripts exist
ls cobrowse/runtime/cobrowse-*.sh | wc -l  # Should be 3

# Verify key patterns
grep "display.env" cobrowse/runtime/cobrowse-start.sh  # Sources config
grep "systemctl --user start" cobrowse/runtime/cobrowse-start.sh  # Starts services
grep "systemctl --user stop" cobrowse/runtime/cobrowse-stop.sh  # Stops services
grep "curl.*9222" cobrowse/runtime/cobrowse-status.sh  # CDP health check

# Make executable
chmod +x cobrowse/runtime/cobrowse-*.sh
```
  </verify>
  <done>Three runtime scripts exist that start services in dependency order with health checks, stop services cleanly, and report detailed status of all 4 components.</done>
</task>

<task type="auto">
  <name>Task 2: Run setup and start scripts to bring up the display stack</name>
  <files>
    (no new files — executes existing scripts)
  </files>
  <action>
Execute the setup and start scripts to bring up the full display stack on this container.

Steps:
1. Make all scripts executable:
   ```bash
   chmod +x cobrowse/setup/cobrowse-setup.sh cobrowse/setup/configure-display.sh
   chmod +x cobrowse/runtime/cobrowse-start.sh cobrowse/runtime/cobrowse-stop.sh cobrowse/runtime/cobrowse-status.sh
   ```

2. Run the setup script:
   ```bash
   bash cobrowse/setup/cobrowse-setup.sh
   ```
   This installs packages, deploys systemd services, configures display.

3. Run the start script:
   ```bash
   bash cobrowse/runtime/cobrowse-start.sh
   ```
   This starts all 4 services and waits for them to be healthy.

4. Run the status script:
   ```bash
   bash cobrowse/runtime/cobrowse-status.sh
   ```
   All 4 components should report OK.

5. Verify CDP endpoint:
   ```bash
   curl -s http://localhost:9222/json/version | head -5
   ```

6. If TigerVNC x0vncserver fails (package not available or can't connect to display), fix the VNC service to use x11vnc as fallback:
   - Check: `which x0vncserver` and `which x11vnc`
   - If x0vncserver unavailable, update tigervnc@.service ExecStart to use x11vnc
   - Re-run daemon-reload and restart

7. If any service fails, check journalctl and fix:
   ```bash
   journalctl --user -u xvfb@99 --no-pager -n 20
   journalctl --user -u tigervnc@99 --no-pager -n 20
   journalctl --user -u novnc@99 --no-pager -n 20
   journalctl --user -u chromium-cdp@99 --no-pager -n 20
   ```

IMPORTANT: This task requires iterating if things fail. The executor should debug and fix issues in the service files or scripts until all 4 services are running. Update the source files in the repo (cobrowse/systemd/ and cobrowse/runtime/) with any fixes, not just the deployed copies.
  </action>
  <verify>
```bash
# All services active
systemctl --user is-active xvfb@99
systemctl --user is-active tigervnc@99
systemctl --user is-active novnc@99
systemctl --user is-active chromium-cdp@99

# CDP responding
curl -s http://localhost:9222/json/version

# Status script reports all green
bash cobrowse/runtime/cobrowse-status.sh
```
  </verify>
  <done>All 4 systemd services are active and healthy. CDP endpoint responds at localhost:9222. noVNC is listening on port 6080. Status script reports 4/4 services OK.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete display stack: Xvfb virtual display, VNC server, noVNC web client, and Chromium with CDP — all managed by systemd services with start/stop/status scripts.</what-built>
  <how-to-verify>
1. Open your laptop browser and navigate to: http://CONTAINER_IP:6080/vnc.html?autoconnect=true
   (The start script prints the exact URL. Replace CONTAINER_IP with the container's Tailscale or LAN IP.)

2. You should see the Chromium browser running on the virtual display. It may show the "Welcome to Chromium" page or a blank tab.

3. Try clicking in the browser address bar and typing a URL (e.g., https://example.com). The page should load.

4. Try right-clicking to verify mouse interaction works.

5. From a terminal on the container, verify CDP:
   ```bash
   curl -s http://localhost:9222/json/version | python3 -m json.tool
   ```

6. Test session persistence — restart the browser service and verify state survives:
   ```bash
   # Navigate to a site with localStorage in the noVNC browser first, then:
   bash cobrowse/runtime/cobrowse-stop.sh
   bash cobrowse/runtime/cobrowse-start.sh
   # Reload noVNC — the browser should remember its previous state
   ```

7. Verify the setup script timing (should be under 5 minutes on a fresh box):
   - If you have a fresh container available, time the setup: `time bash cobrowse/setup/cobrowse-setup.sh`
   - Otherwise, trust that apt-get install is fast on these Hetzner boxes
  </how-to-verify>
  <resume-signal>Type "approved" if noVNC shows Chromium and interaction works, or describe any issues you see.</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `systemctl --user is-active xvfb@99` returns "active"
2. `systemctl --user is-active tigervnc@99` returns "active"
3. `systemctl --user is-active novnc@99` returns "active"
4. `systemctl --user is-active chromium-cdp@99` returns "active"
5. `curl -s http://localhost:9222/json/version` returns JSON with Chromium version
6. noVNC accessible at http://CONTAINER_IP:6080/vnc.html
7. Human verified: can see and interact with Chromium via noVNC
8. Browser session persists across service restart
</verification>

<success_criteria>
Phase 1 success criteria from ROADMAP.md:
1. User opens noVNC URL in laptop browser and sees Chromium running on virtual display
2. User can click and type in Chromium via noVNC interface
3. Chromium CDP debugger accessible at localhost:9222 from container shell
4. Browser session survives service restart (cookies and localStorage persist via --user-data-dir)
5. Setup script installs entire stack on fresh Ubuntu 24.04 container in under 5 minutes
</success_criteria>

<output>
After completion, create `.planning/phases/01-display-stack-foundation/01-02-SUMMARY.md`
</output>
